// Lexer.h

#ifndef LEXER_H
#define LEXER_H

#include <stdio.h>
#include <fstream>
#include <string>
#include <vector>


enum Token_Type {
    TOKEN_IDENTIFIER,          // abcd  sdf2324  dfs_23fs56df
    TOKEN_KEYWORD,
    TOKEN_DATA_TYPE,
    TOKEN_NUMERIC_LITERAL,     // 23434 12.656
    TOKEN_CHAR_LITERAL,        // 'A'
    TOKEN_STRING_LITERAL,      // "fds..."
    TOKEN_SEPARATOR,           // ,
    TOKEN_DELIMITER,           // ;

    /* brackets */
    TOKEN_LEFT_BRACE,          // {
    TOKEN_RIGHT_BRACE,         // }
    TOKEN_LEFT_PAREN,          // (
    TOKEN_RIGHT_PAREN,         // )
    TOKEN_LEFT_SQUARE,         // [
    TOKEN_RIGHT_SQUARE,        // ]

    /* unary ops */
    TOKEN_NOT,                 // !
    TOKEN_BIT_NOT,             // ~
    TOKEN_INCREMENT,           // ++
    TOKEN_DECREMENT,           // --

    /* binary ops */
    TOKEN_PLUS,                // +
    TOKEN_MINUS,               // -
    TOKEN_DIVIDE,              // /
    TOKEN_MOD,                 // %
    TOKEN_PLUSEQ,              // +=
    TOKEN_MINUSEQ,             // -=
    TOKEN_MULTIPLYEQ,          // *=
    TOKEN_DIVIDEEQ,            // /=
    TOKEN_MODEQ,               // %=
    TOKEN_LESS,                // <
    TOKEN_GREATER,             // >
    TOKEN_LESSEQ,              // <=
    TOKEN_GREATEREQ,           // >=
    TOKEN_ASSIGN,              // =
    TOKEN_EQUAL,               // ==
    TOKEN_NOTEQ,               // !=
    TOKEN_AND,                 // &&
    TOKEN_OR,                  // ||
    TOKEN_BIT_OR,              // |
    TOKEN_XOR,                 // ^
    TOKEN_ANDEQ,               // &&=
    TOKEN_OREQ,                // ||=
    TOKEN_BIT_ANDEQ,           // &=
    TOKEN_BIT_OREQ,            // |=
    TOKEN_XOREQ,               // ^=
    TOKEN_DOT,                 // .

    /* non context-free (must be interpreted at parsing) */
    TOKEN_STAR,                // * (multiplication / pointer de-reference)
    TOKEN_AMPERSAND,           // & (binary and / address-of)
};


// partial types
// (for raw strings, before having a determined token)

enum Partial_Token_Type {
    PTOK_NUMERIC,     // pure numbers
    PTOK_ALNUM,       // both alphabets and numbers (starts with alpha)
};


struct Token {
    std::string val;
    Token_Type type;
};

struct Lexer {
    std::string line;
    int line_num;

    std::vector<Token> tokens;
};

//          list of keywords for the language
// *****************************************************

const std::string DATA_TYPES[] = {
    "void",
    "int",
    "float",
    "char",
    "string"
};

const std::string KEYWORDS[] = {
    /* literals */
    "NULL",

    /* control flow */
    "if",
    "else",
    "for",
    "while",

    /* jumps */
    "return",
    "break",
    "continue",
};

const size_t TOTAL_KEYWORDS = sizeof(KEYWORDS) / sizeof(KEYWORDS[0]);
const size_t TOTAL_DATA_TYPES = sizeof(DATA_TYPES) / sizeof(DATA_TYPES[0]);

//                Helper functions
// ************************************************

bool is_alpha(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

bool is_numeric(char c)
{
    return (c >= '0' && c <= '9');
}

// (For Debugging)
//
// to print the list of tokens generated by the lexer
void print_tokens(Lexer* lexer)
{
    for (Token& tok : lexer->tokens) {
	printf("<\'%s\', %d>\n", tok.val.c_str(), tok.type);
    }
}

#endif
